# sequence from Mattheiu Blanchette 1/28/05 in /cluster/store8/blanchem/hsa13/ancestors1
    ssh kksilo
    mkdir -p /cluster/store10/ancestor/borEut1/sequence
    ln -s /cluster/store10/ancestor/borEut1 /cluster/data/borEut1
    cd /cluster/data/borEut1/sequence
    g=PREDICTIONANCESTRAL3
    echo $g > list
    for i in /cluster/store8/blanchem/hsa13/ancestors1/*
    do 
	f=`basename $i .ancestors`
	faSomeRecords $i list stdout | sed "s/$g/$f/" | tr -d '-' > $f.fa
	echo $i
    done
    cat *.fa > borEut1.fa
    scaffoldFaToAgp borEut1.fa  

    cd ..
    mkdir 15
    mv sequence/borEut1.agp 15/chr15.agp 
    mv sequence/borEut1.lft 15/chr15.lft 
    cat */*/*.lft > jkStuff/liftAll.lft  

    # Create chromosome FA file from AGP and file of masked scaffolds
    cd 15
    agpToFa -simpleMultiMixed chr15.agp chr15 chr15.fa ../sequence/borEut1.fa 

# CREATING DATABASE 
    # Create the database.
    ssh hgwdev
    echo 'create database borEut1' | hgsql ''

# STORE SEQUENCE AND ASSEMBLY INFORMATION 
    # Translate to nib
    cd /cluster/data/borEut1
    mkdir nib
    faToNib -softMask 15/chr15.fa nib/chr15.nib

    faToTwoBit */chr*.fa borEut1.2bit
    ln -s /cluster/data/borEut1/borEut1.2bit /gbdb/borEut1/nib/

    # Make symbolic links from /gbdb/borEut1/nib to the real nibs.
    mkdir -p /gbdb/borEut1/nib
    ln -s /cluster/data/borEut1/nib/chr15.nib  /gbdb/borEut1/nib

    hgsql borEut1  < $HOME/kent/src/hg/lib/chromInfo.sql             

    hgNibSeq -preMadeNib borEut1 /gbdb/borEut1/nib 15/chr15.fa
    echo "select chrom,size from chromInfo" | hgsql -N borEut1 > chrom.sizes
    echo 15 > chrom.lst

    # create assembly and gap tracks
    hgGoldGapGl -noGl -chromLst=chrom.lst borEut1 /cluster/data/borEut1 .

    echo "create table grp (PRIMARY KEY(NAME)) select * from hg17.grp" | hgsql borEut1 

    cd 15
    splitFaIntoContigs chr15.agp chr15.fa . -nSize=5000000 
    cd ..

    # stupid move to restore sanity
    mv 15 old.15
    mv old.15/15 15

# MAKE GCPERCENT 
    mkdir -p /cluster/data/borEut1/bed/gcPercent
    cd /cluster/data/borEut1/bed/gcPercent
    hgsql borEut1  < ~/src/hg/lib/gcPercent.sql

    # load gcPercent table
    hgGcPercent borEut1 ../../nib

    cd ../..

    echo 'INSERT INTO defaultDb VALUES ("BorealEutherian", "borEut1");' | hgsql -h genome-testdb hgcentraltest

    # Add dbDb and defaultDb entries:
    echo 'insert into dbDb (name, description, nibPath, organism,  \
          defaultPos, active, orderKey, genome, scientificName,  \
          htmlPath, hgNearOk)  \
          values("borEut1", "Jan. 2005", \
          "/gbdb/borEut1/nib", "BoreoEutherian", "chr15:13120186-13124117", 1, \
          44, "BoreoEutherian", "BoreoEutherian", \
          "/gbdb/borEut1/html/description.html", 0);' \
    | hgsql -h genome-testdb hgcentraltest
    echo 'update defaultDb set name = "borEut1" where genome = "BoreoEutherian"' | hgsql -h genome-testdb hgcentraltest
    echo 'insert into genomeClade (genome, clade, priority) values ("BoreoEutherian", "vertebrate",65);'  \
	| hgsql -h genome-testdb hgcentraltest

    # Make trackDb table so browser knows what tracks to expect:
    cd $HOME/kent/src/hg/makeDb/trackDb
    mkdir -p borEut/borEut1
    cvs add borEut
    cvs add borEut/borEut1
    cvs ci borEut

    # Edit that makefile to add borEut1 in all the right places and do
    make update

# SIMPLE REPEATS (TRF) 
    ssh kksilo
    mkdir -p /cluster/data/borEut1/bed/simpleRepeat
    cd /cluster/data/borEut1/bed/simpleRepeat
    mkdir trf
    tcsh
    cp /dev/null jobs.csh
    foreach d (/cluster/data/borEut1/*/chr*_?{,?})
      set ctg = $d:t
      foreach f ($d/${ctg}.fa)
        set fout = $f:t:r.bed
        echo $fout
        echo "/cluster/bin/i386/trfBig -trf=/cluster/bin/i386/trf $f /dev/null -bedAt=trf/$fout -tempDir=/tmp" \
        >> jobs.csh
      end
    end
    csh -ef jobs.csh >&! jobs.log &
    # check on this with
    tail -f jobs.log
    wc -l jobs.csh
    ls -1 trf | wc -l
    endsInLf trf/*
    # When job is done do:
    liftUp simpleRepeat.bed /cluster/data/borEut1/jkStuff/liftAll.lft warn  trf/*.bed

    # Load into the database:
    ssh hgwdev
    hgLoadBed borEut1 simpleRepeat \
      /cluster/data/borEut1/bed/simpleRepeat/simpleRepeat.bed \
      -sqlTable=$HOME/kent/src/hg/lib/simpleRepeat.sql
    featureBits borEut1 simpleRepeat
    # 591095 bases of 70435997 (0.839%) in intersection

# REPEAT MASKING
    #- Make the run directory and job list:
    cd /cluster/data/borEut1
    cd 15
    for i in chr*_*; do  cd $i; faSplit gap $i.fa 500000 "$i"_ -lift=$i.lft -minGapSize=100; cd ..; done

    cat << '_EOF_' > jkStuff/RMChicken
#!/bin/csh -fe

cd $1
pushd .
/bin/mkdir -p /tmp/borEut1/$2
/bin/cp $2 /tmp/borEut1/$2/
cd /tmp/borEut1/$2
/cluster/bluearc/RepeatMasker/RepeatMasker -ali -s -spec chicken $2
popd
/bin/cp /tmp/borEut1/$2/$2.out ./
if (-e /tmp/borEut1/$2/$2.align) /bin/cp /tmp/borEut1/$2/$2.align ./
if (-e /tmp/borEut1/$2/$2.tbl) /bin/cp /tmp/borEut1/$2/$2.tbl ./
if (-e /tmp/borEut1/$2/$2.cat) /bin/cp /tmp/borEut1/$2/$2.cat ./
/bin/rm -fr /tmp/borEut1/$2/*
/bin/rmdir --ignore-fail-on-non-empty /tmp/borEut1/$2
/bin/rmdir --ignore-fail-on-non-empty /tmp/borEut1
'_EOF_'
    # << this line makes emacs coloring happy
    chmod +x jkStuff/RMChicken
    mkdir RMRun
    for i in `cat chrom.lst`
    do
	f=$i/*/*_*_.fa
	for j in $f
	do
	    d=`dirname $j`
	    f=`basename $j`
	    echo /cluster/data/borEut1/jkStuff/RMChicken \
		 /cluster/data/borEut1/$d $f \
	       '{'check out line+ /cluster/data/borEut1/$d/$f.out'}' \
	done
    done > RMRun/RMJobs

    #- Do the run
    ssh kk
    cd /cluster/data/borEut1/RMRun
    para create RMJobs
    para try, para check, para check, para push, para check,...
# Completed: 159 of 159 jobs
# CPU time in finished jobs:     850743s   14179.05m   236.32h    9.85d  0.027 y
# IO & Wait Time:                 27829s     463.82m     7.73h    0.32d  0.001 y
# Average job time:                5526s      92.09m     1.53h    0.06d
# Longest job:                    11363s     189.38m     3.16h    0.13d
# Submission to last job:         11428s     190.47m     3.17h    0.13d

    #- Lift up the 500KB chunk .out's to 5MB ("pseudo-contig") level
    ssh kksilo
    cd /cluster/data/borEut1
    foreach d (*/chr*_?{,?})
      set contig = $d:t
      echo $contig
      liftUp $d/$contig.fa.out $d/$contig.lft warn $d/${contig}_*.fa.out > /dev/null
    end

    #- Lift pseudo-contigs to chromosome level
    foreach c (`cat chrom.lst`)
      echo lifting $c
      cd $c
      if (-e lift/ordered.lft && ! -z lift/ordered.lft) then
        liftUp chr$c.fa.out lift/ordered.lft warn `cat lift/oOut.lst` \
        > /dev/null
      endif
      if (-e lift/random.lft && ! -z lift/random.lft) then
        liftUp chr${c}_random.fa.out lift/random.lft warn `cat lift/rOut.lst` \
        > /dev/null
      endif
      cd ..
    end

    #- Load the .out files into the database with:
    ssh hgwdev
    cd /cluster/data/borEut1
    hgLoadOut borEut1 */chr*.fa.out

# PROCESS SIMPLE REPEATS INTO MASK 
    # After the simpleRepeats track has been built, make a filtered version 
    # of the trf output: keep trf's with period <= 12:
    ssh kksilo
    cd /cluster/data/borEut1/bed/simpleRepeat
    mkdir -p trfMask
    foreach f (trf/chr*.bed)
      awk '{if ($5 <= 12) print;}' $f > trfMask/$f:t
    end
    # Lift up filtered trf output to chrom coords as well:
    cd /cluster/data/borEut1
    mkdir bed/simpleRepeat/trfMaskChrom
    foreach c (`cat chrom.lst`)
      if (-e $c/lift/ordered.lst) then
        perl -wpe 's@(\S+)@bed/simpleRepeat/trfMask/$1.bed@' \
          $c/lift/ordered.lst > $c/lift/oTrf.lst
        liftUp bed/simpleRepeat/trfMaskChrom/chr$c.bed \
          jkStuff/liftAll.lft warn `cat $c/lift/oTrf.lst`
      endif
      if (-e $c/lift/random.lst) then
        perl -wpe 's@(\S+)@bed/simpleRepeat/trfMask/$1.bed@' \
           $c/lift/random.lst > $c/lift/rTrf.lst
        liftUp bed/simpleRepeat/trfMaskChrom/chr${c}_random.bed \
          jkStuff/liftAll.lft warn `cat $c/lift/rTrf.lst`
      endif
    end
    # Here's the coverage for the filtered TRF:
    ssh hgwdev
    cat /cluster/data/borEut1/bed/simpleRepeat/trfMaskChrom/*.bed > /tmp/filtTrf.bed
    featureBits borEut1 /tmp/filtTrf.bed
    # 254200 bases of 70435997 (0.361%) in intersection

# MASK SEQUENCE WITH REPEATMASKER AND SIMPLE REPEAT/TRF 
    ssh kksilo
    cd /cluster/data/borEut1
    # Soft-mask (lower-case) the contig and chr .fa's, 
    # then make hard-masked versions from the soft-masked.  
    set trfCtg=bed/simpleRepeat/trfMask
    set trfChr=bed/simpleRepeat/trfMaskChrom
    foreach f (*/chr*.fa)
      echo "repeat- and trf-masking $f"
      maskOutFa -soft $f $f.out $f
      set chr = $f:t:r
      maskOutFa -softAdd $f $trfChr/$chr.bed $f
      echo "hard-masking $f"
      maskOutFa $f hard $f.masked
    end
# WARNING: negative rEnd: -427 chr15:11970703-11971000 L1M3e
# WARNING: negative rEnd: -362 chr15:11971301-11971482 L1M3e
# WARNING: negative rEnd: -448 chr15:11972390-11972472 L1M3e
# WARNING: negative rEnd: -253 chr15:12454361-12454409 L1M2
# WARNING: negative rEnd: -426 chr15:50421587-50421874 L1M3e
# WARNING: negative rEnd: -363 chr15:50422163-50422322 L1M3e

    foreach c (`cat chrom.lst`)
      echo "repeat- and trf-masking contigs of chr$c, chr${c}_random"
      foreach d ($c/chr*_?{,?})
        set ctg=$d:t
        set f=$d/$ctg.fa
        maskOutFa -soft $f $f.out $f
        maskOutFa -softAdd $f $trfCtg/$ctg.bed $f
        maskOutFa $f hard $f.masked
      end
    end
# same deal here:
#WARNING: negative rEnd: -25 chr2_19:4344750-4345006 GGLTR3B1
    #- Rebuild the nib files, using the soft masking in the fa:
    mkdir nib
    foreach f (*/chr*.fa)
      faToNib -softMask $f nib/$f:t:r.nib
    end
    # Make one big 2bit file as well, and make a link to it in 
    # /gbdb/borEut1/nib because hgBlat looks there:
    faToTwoBit */chr*.fa borEut1.2bit
    ln -s /cluster/data/borEut1/borEut1.2bit /gbdb/borEut1/nib/

# PUT MASKED SEQUENCE OUT FOR CLUSTER RUNS 
    ssh kkr1u00
    # Chrom-level mixed nibs that have been repeat- and trf-masked:
    rm -rf /iscratch/i/borEut1/nib
    mkdir /iscratch/i/borEut1/nib
    cp -p /cluster/data/borEut1/nib/chr*.nib /iscratch/i/borEut1/nib
    # Pseudo-contig fa that have been repeat- and trf-masked:
    rm -rf /iscratch/i/borEut1/trfFa
    mkdir /iscratch/i/borEut1/trfFa
    foreach d (/cluster/data/borEut1/*/chr*_?{,?})
      cp $d/$d:t.fa /iscratch/i/borEut1/trfFa
    end
    cp -p /cluster/data/borEut1/borEut1.2bit /iscratch/i/borEut1/
    iSync

# MAKE 10.OOC, 11.OOC FILES FOR BLAT 
    # Use -repMatch=843 (based on size -- for human we use 1024, and 
    # dog size is 2359845093 / 2866216770 = ~82.3% of human judging by 
    # gapless genome size from featureBits)
    ssh kolossus
    mkdir /cluster/data/borEut1/bed/ooc
    mkdir -p /cluster/bluearc/borEut1/
    cd /cluster/data/borEut1/bed/ooc
    ls -1 /cluster/data/borEut1/nib/chr*.nib > nib.lst
    blat nib.lst /dev/null /dev/null -tileSize=11 -makeOoc=/cluster/bluearc/borEut1/11.ooc -repMatch=1024
# Wrote 8 overused 11-mers to /cluster/bluearc/borEut1/11.ooc
    blat nib.lst /dev/null /dev/null -tileSize=10 -makeOoc=/cluster/bluearc/borEut1/10.ooc -repMatch=843
# Wrote 67 overused 10-mers to /cluster/bluearc/borEut1/10.ooc
    ssh kkr1u00
    cp -p /cluster/bluearc/borEut1/*.ooc /iscratch/i/borEut1/
    iSync


# MAKE Human Proteins track 
    ssh kksilo
    mkdir -p /cluster/data/borEut1/blastDb
    cd /cluster/data/borEut1/blastDb
    for i in `cat ../chrom.lst`; do ls -1 ../$i/*/*.fa  ; done > list  
    for i in `cat list`
    do
	f=`basename $i`
	sed "s/ .*$//" $i > $f 
	formatdb -i $f -p F
    done
    rm *.log *.fa list
    cd ..
    # for i in `cat chrom.lst`; do cat  $i/chr*/*.lft  ; done > jkStuff/subChr.lft

    ssh kkr1u00
    mkdir -p /iscratch/i/borEut1/blastDb
    cd /cluster/data/borEut1/blastDb
    for i in nhr nin nsq; do cp *.$i /iscratch/i/borEut1/blastDb     ; echo $i; done

    cd
    iSync > sync.out

    mkdir -p /cluster/data/borEut1/bed/tblastn.hg17KG
    cd /cluster/data/borEut1/bed/tblastn.hg17KG
    echo  /iscratch/i/borEut1/blastDb/*.nsq  | xargs ls -S | sed "s/\.nsq//"  > query.lst  
    # back to kksilo
    exit

    cd /cluster/data/borEut1/bed/tblastn.hg17KG
    mkdir -p /cluster/bluearc/borEut1/bed/tblastn.hg17KG/kgfa
    split -l 70 /cluster/data/hg17/bed/blat.hg17KG/hg17KG.psl /cluster/bluearc/borEut1/bed/tblastn.hg17KG/kgfa/kg
    ln -s /cluster/bluearc/borEut1/bed/tblastn.hg17KG/kgfa kgfa
    cd kgfa
    for i in *; do pslxToFa $i $i.fa; rm $i; done
    cd ..
    ls -1S kgfa/*.fa > kg.lst
    mkdir -p /cluster/bluearc/borEut1/bed/tblastn.hg17KG/blastOut
    ln -s /cluster/bluearc/borEut1/bed/tblastn.hg17KG/blastOut
    for i in `cat kg.lst`; do  mkdir blastOut/`basename $i .fa`; done
    tcsh
    cat << '_EOF_' > blastGsub
#LOOP
blastSome $(path1) {check in line $(path2)} {check out exists blastOut/$(root2)/q.$(root1).psl } 
#ENDLOOP
'_EOF_'
    cat << '_EOF_' > blastSome
#!/bin/sh
BLASTMAT=/iscratch/i/blast/data
export BLASTMAT
g=`basename $2`
f=/tmp/`basename $3`.$g
for eVal in 0.01 0.001 0.0001 0.00001 0.000001 1E-09 1E-11
do
if /scratch/blast/blastall -M BLOSUM80 -m 0 -F no -e $eVal -p tblastn -d $1 -i $2 -o $f.8
then
        mv $f.8 $f.1
        break;
fi
done
if test -f  $f.1
then
    if /cluster/bin/i386/blastToPsl $f.1 $f.2
    then
        liftUp -nosort -type=".psl" -nohead $f.3 ../../jkStuff/liftAll.lft carry $f.2       
        liftUp -nosort -type=".psl" -pslQ -nohead $3.tmp /cluster/data/hg17/bed/blat.hg17KG/protein.lft warn $f.3       
        if pslCheck -prot $3.tmp                                                                          
        then                                                                                              
            mv $3.tmp $3                                                                                  
            rm -f $f.1 $f.2 $f.3 
        fi
        exit 0                                                                                            
    fi                                                                                                    
fi                                                                                                        
rm -f $f.1 $f.2 $3.tmp $f.8 $f.3
exit 1
'_EOF_'

    chmod +x blastSome
    gensub2 query.lst kg.lst blastGsub blastSpec

    ssh kk
    cd /cluster/data/borEut1/bed/tblastn.hg17KG
    para create blastSpec
    para push
# Completed: 6633 of 6633 jobs
# CPU time in finished jobs:    2509978s   41832.96m   697.22h   29.05d  0.080 y
# IO & Wait Time:                 57960s     966.00m    16.10h    0.67d  0.002 y
# Average job time:                 387s       6.45m     0.11h    0.00d
# Longest job:                     2437s      40.62m     0.68h    0.03d
# Submission to last job:          7992s     133.20m     2.22h    0.09d

    cat << '_EOF_' > chainGsub
#LOOP
chainSome $(path1)
#ENDLOOP
'_EOF_'

    cat << '_EOF_' > chainOne
(cd $1; cat q."$2"* | simpleChain -prot -outPsl -maxGap=200000 stdin ../c.`basename $1`.$2.psl)
'_EOF_'
    chmod +x chainOne

    for j in blastOut/kg??; do for i in `cat ../../chrom.lst`; do echo chainOne $j chr"$i"; done ; done > chainSpec

    ssh kki
    cd /cluster/data/borEut1/bed/tblastn.hg17KG
    para create chainSpec
    para push
# Completed: 603 of 603 jobs
# CPU time in finished jobs:      34193s     569.88m     9.50h    0.40d  0.001 y
# IO & Wait Time:                  2951s      49.18m     0.82h    0.03d  0.000 y
# Average job time:                  62s       1.03m     0.02h    0.00d
# Longest job:                      814s      13.57m     0.23h    0.01d
# Submission to last job:          3282s      54.70m     0.91h    0.04d

    exit
    # back to kksilo
    cd /cluster/data/borEut1/bed/tblastn.hg17KG/blastOut
    for i in kg??
    do 
	cat c.$i.*.psl | awk "(\$13 - \$12)/\$11 > 0.6 {print}" > c60.$i.psl
	sort -rn c60.$i.psl | pslUniq stdin u.$i.psl
	awk "((\$1 / \$11) ) > 0.90 { print   }" c60.$i.psl > m60.$i.psl
	echo $i
    done

    cat u.*.psl m60* | sort -T /tmp -k 14,14 -k 17,17n -k 17,17n  | uniq  > /cluster/data/borEut1/bed/tblastn.hg17KG/blastHg17KG.psl
    cd ..
    ssh hgwdev
    cd /cluster/data/borEut1/bed/tblastn.hg17KG
    hgLoadPsl borEut1 blastHg17KG.psl

    # back to kksilo
    rm -rf blastOut
# End tblastn

# PRODUCING GENSCAN PREDICTIONS 
    ssh hgwdev
    mkdir /cluster/data/borEut1/bed/genscan
    cd /cluster/data/borEut1/bed/genscan
    # Check out hg3rdParty/genscanlinux to get latest genscan:
    cvs co hg3rdParty/genscanlinux
    # Run on small cluster (more mem than big cluster).
    ssh kki
    cd /cluster/data/borEut1/bed/genscan
    # Make 3 subdirectories for genscan to put their output files in
    mkdir gtf pep subopt
    # Generate a list file, genome.list, of all the hard-masked contigs that 
    # *do not* consist of all-N's (which would cause genscan to blow up)
    rm -f genome.list
    touch genome.list
    foreach f ( `ls -1S /cluster/data/borEut1/*/chr*_*/chr*_?{,?}.fa.masked` )
      egrep '[ACGT]' $f > /dev/null
      if ($status == 0) echo $f >> genome.list
    end
    wc -l genome.list
    # Create template file, gsub, for gensub2.  For example (3-line file):
    cat << '_EOF_' > gsub
#LOOP
/cluster/bin/i386/gsBig {check in line+ $(path1)} {check out line gtf/$(root1).gtf} -trans={check out line pep/$(root1).pep} -subopt={check out line subopt/$(root1).bed} -exe=hg3rdParty/genscanlinux/genscan -par=hg3rdParty/genscanlinux/HumanIso.smat -tmp=/tmp -window=2400000
#ENDLOOP
'_EOF_'
    # << this line makes emacs coloring happy
    gensub2 genome.list single gsub jobList
    para create jobList
    para try, check, push, check, ...
# Completed: 11 of 11 jobs
# CPU time in finished jobs:       1865s      31.09m     0.52h    0.02d  0.000 y
# IO & Wait Time:                    39s       0.64m     0.01h    0.00d  0.000 y
# Average job time:                 173s       2.88m     0.05h    0.00d
# Longest job:                      253s       4.22m     0.07h    0.00d
# Submission to last job:           253s       4.22m     0.07h    0.00d


    # Convert these to chromosome level files as so:
    ssh kksilo
    cd /cluster/data/borEut1/bed/genscan
    liftUp genscan.gtf ../../jkStuff/liftAll.lft warn gtf/*.gtf
    liftUp genscanSubopt.bed ../../jkStuff/liftAll.lft warn subopt/*.bed
    cat pep/*.pep > genscan.pep

    # Load into the database as so:
    ssh hgwdev
    cd /cluster/data/borEut1/bed/genscan
    ldHgGene borEut1 genscan genscan.gtf
    hgPepPred borEut1 generic genscanPep genscan.pep
    hgLoadBed borEut1 genscanSubopt genscanSubopt.bed
#END GENSCAN

# MAKE Human Known Gene mRNAs Mapped by BLATZ track (hg17 
    # Create working directory and extract known gene mrna from database
    ssh kk
    mkdir -p /cluster/data/borEut1/bed/blatz.hg17KG
    cd /cluster/data/borEut1/bed/blatz.hg17KG

    # Do parasol job to align via blatz
    mkdir run0
    cd run0
    mkdir psl
    # awk '{print $1;}' /cluster/data/borEut1/chrom.sizes > genome.lst
    ls -1S /iscratch/i/borEut1/trfFa/*.fa > genome.lst
    for i in `cat genome.lst` ;  do f=`basename $i .fa`; mkdir psl/$f ; done 
    for i in  /iscratch/i/hg17/knownRna2/*.fa ; do echo $i; done > mrna.lst
    cat << '_EOF_' > doBlatz
#!/bin/sh
f=/tmp/`basename $1`.`basename $2`
if blatz -rna -minScore=6000 -out=psl $1 $2 $f.1
then
    if liftUp -nosort -type=".psl" -nohead $f.2 ../../../jkStuff/liftAll.lft carry $f.1
    then
	mv $f.2 $3
	rm $f.1
	exit 0
    fi
fi
rm $f.1 $f.2
exit 1
'_EOF_'
    chmod +x doBlatz
    cat << '_EOF_' > gsub
#LOOP
doBlatz   $(path1) $(path2) {check out line psl/$(root1)/$(root2).psl}
#ENDLOOP
'_EOF_'
    # << this line keeps emacs coloring happy
    gensub2 genome.lst mrna.lst gsub spec
    para create spec
    # Then do usual para try/para push/para time
# Completed: 6303 of 6303 jobs
# CPU time in finished jobs:     920417s   15340.29m   255.67h   10.65d  0.029 y
# IO & Wait Time:                 23131s     385.51m     6.43h    0.27d  0.001 y
# Average job time:                 150s       2.49m     0.04h    0.00d
# Longest job:                     1064s      17.73m     0.30h    0.01d
# Submission to last job:          1632s      27.20m     0.45h    0.02d

    # Do sort and near-besting on file server
    ssh kksilo
    cd /cluster/data/borEut1/bed/blatz.hg17KG/run0
    catDir -r psl | pslFilter -minScore=100 -minAli=255 -noHead stdin stdout | sort -k 10 > ../filtered.psl
    cd ..
    pslReps filtered.psl nearBest.psl /dev/null -nohead -minAli=0.8 -nearTop=0.01 -minCover=0.8
    sort -k 14 nearBest.psl > blatzHg17KG.psl

    # Clean up
    rm -r run0/psl 

    # Load into database
    ssh hgwdev
    cd /cluster/data/borEut1/bed/blatz.hg17KG
    hgLoadPsl borEut1 blatzHg17KG.psl 

#END BLATZ

# BLASTZ SWAP FOR hg17 vs borEut1 BLASTZ TO CREATE borEut1 vs hg17 BLASTZ
    ssh kolossus
    mkdir -p /cluster/data/borEut1/bed/blastz.hg17
    cd /cluster/data/borEut1/bed/blastz.hg17
    set aliDir = /cluster/data/hg17/bed/blastz.borEut1
    cp $aliDir/S1.len S2.len
    cp $aliDir/S2.len S1.len
    mkdir unsorted axtChrom
    cat $aliDir/axtChrom/chr*.axt \
    | axtSwap stdin $aliDir/S1.len $aliDir/S2.len stdout \
    | axtSplitByTarget stdin unsorted
    # Sort the shuffled .axt files.
    foreach f (unsorted/*.axt)
      echo sorting $f:t:r
      axtSort $f axtChrom/$f:t
    end
    du -sh $aliDir/axtChrom unsorted axtChrom
    # 409M    /cluster/data/hg17/bed/blastz.borEut1/axtChrom
    # 409M    unsorted
    # 409M    axtChrom

    rm -r unsorted

# CHAIN HUMAN BLASTZ 
    # Run axtChain on little cluster
    ssh kki
    cd /cluster/data/borEut1/bed/blastz.hg17
    mkdir -p axtChain/run1
    cd axtChain/run1
    mkdir out chain
    ls -1S /cluster/data/borEut1/bed/blastz.hg17/axtChrom/*.axt  > input.lst
    cat << '_EOF_' > gsub
#LOOP
doChain {check in line+ $(path1)} {check out line+ chain/$(root1).chain} {check out exists out/$(root1).out}
#ENDLOOP
'_EOF_'
    # << this line makes emacs coloring happy

    cat << '_EOF_' > doChain
#!/bin/csh
axtChain $1 \
  /iscratch/i/borEut1/nib \
  /iscratch/i/gs.18/build35/bothMaskedNibs $2 > $3
'_EOF_'
    # << this line makes emacs coloring happy
    chmod a+x doChain
    gensub2 input.lst single gsub jobList
    para create jobList
    para try, check, push, check...
# Completed: 1 of 1 jobs
# CPU time in finished jobs:        189s       3.16m     0.05h    0.00d  0.000 y
# IO & Wait Time:                    11s       0.18m     0.00h    0.00d  0.000 y
# Average job time:                 200s       3.33m     0.06h    0.00d
# Longest job:                      200s       3.33m     0.06h    0.00d
# Submission to last job:           200s       3.33m     0.06h    0.00d

    # now on the cluster server, sort chains
    ssh kksilo
    cd /cluster/data/borEut1/bed/blastz.hg17/axtChain
    chainMergeSort run1/chain/*.chain > all.chain
    chainSplit chain all.chain
    rm run1/chain/*.chain

    # take a look at score distr's
    foreach f (chain/*.chain)
      grep chain $f | awk '{print $2;}' | sort -nr > /tmp/score.$f:t:r
      echo $f:t:r
      textHistogram -binSize=4000 /tmp/score.$f:t:r
      echo ""
    end

    mv all.chain all.chain.unfiltered
    chainFilter -minScore=50000 all.chain.unfiltered > all.chain
    rm chain/*
    chainSplit chain all.chain
    gzip all.chain.unfiltered

    # Load chains into database
    ssh hgwdev
    cd /cluster/data/borEut1/bed/blastz.hg17/axtChain/chain
    foreach i (*.chain)
        set c = $i:r
        hgLoadChain borEut1 ${c}_chainHg17 $i
    end
    featureBits borEut1 chainHg17Link
    # 54236215 bases of 70435997 (77.001%) in intersection

# NET HUMAN BLASTZ 
    ssh kksilo
    cd /cluster/data/borEut1/bed/blastz.hg17/axtChain
    chainPreNet all.chain ../S1.len ../S2.len stdout \
    | chainNet stdin -minSpace=1 ../S1.len ../S2.len stdout /dev/null \
    | netSyntenic stdin noClass.net

    # Add classification info using db tables:
    ssh hgwdev
    cd /cluster/data/borEut1/bed/blastz.hg17/axtChain
    netClass noClass.net borEut1 hg17 human.net

    # Make a 'syntenic' subset:
    ssh kksilo
    cd /cluster/data/borEut1/bed/blastz.hg17/axtChain
    rm noClass.net
    # Make a 'syntenic' subset of these with
    netFilter -syn human.net > humanSyn.net

    # Load the nets into database 
    ssh hgwdev
    cd /cluster/data/borEut1/bed/blastz.hg17/axtChain
    netFilter -minGap=10 human.net |  hgLoadNet borEut1 netHg17 stdin
    netFilter -minGap=10 humanSyn.net | hgLoadNet borEut1 netSyntenyHg17 stdin
    # Add entries for chainHg17, netHg17, syntenyHg17 to dog/borEut1 trackDb


# GENERATE HG17 MAF FOR MULTIZ FROM NET 
    ssh kksilo
    cd /cluster/data/borEut1/bed/blastz.hg17/axtChain
    netSplit human.net net
    cd /cluster/data/borEut1/bed/blastz.hg17
    mkdir axtNet
    foreach f (axtChain/net/*)
      set chr = $f:t:r
      netToAxt $f axtChain/chain/$chr.chain /cluster/data/borEut1/nib \
        /cluster/data/hg17/nib stdout | axtSort stdin axtNet/$chr.axt
    end
    mkdir mafNet
    foreach f (axtNet/chr*.axt)
      set maf = mafNet/$f:t:r.maf
      axtToMaf $f /cluster/data/borEut1/chrom.sizes /cluster/data/hg17/chrom.sizes $maf -tPrefix=borEut1. -qPrefix=hg17.
    end
    }
# BLASTZ SWAP FOR canFam1 vs borEut1 BLASTZ TO CREATE borEut1 vs canFam1 BLASTZ
    ssh kolossus
    mkdir -p /cluster/data/borEut1/bed/blastz.canFam1
    cd /cluster/data/borEut1/bed/blastz.canFam1
    set aliDir = /cluster/data/canFam1/bed/blastz.borEut1
    cp $aliDir/S1.len S2.len
    cp $aliDir/S2.len S1.len
    mkdir unsorted axtChrom
    cat $aliDir/axtChrom/chr*.axt \
    | axtSwap stdin $aliDir/S1.len $aliDir/S2.len stdout \
    | axtSplitByTarget stdin unsorted
    # Sort the shuffled .axt files.
    foreach f (unsorted/*.axt)
      echo sorting $f:t:r
      axtSort $f axtChrom/$f:t
    end
    du -sh $aliDir/axtChrom unsorted axtChrom
    # 409M    /cluster/data/canFam1/bed/blastz.borEut1/axtChrom
    # 409M    unsorted
    # 409M    axtChrom

    rm -rf unsorted

# CHAIN DOG BLASTZ 
    # Run axtChain on little cluster
    ssh kki
    cd /cluster/data/borEut1/bed/blastz.canFam1
    mkdir -p axtChain/run1
    cd axtChain/run1
    mkdir out chain
    ls -1S /cluster/data/borEut1/bed/blastz.canFam1/axtChrom/*.axt  > input.lst
    cat << '_EOF_' > gsub
#LOOP
doChain {check in line+ $(path1)} {check out line+ chain/$(root1).chain} {check out exists out/$(root1).out}
#ENDLOOP
'_EOF_'
    # << this line makes emacs coloring happy

    cat << '_EOF_' > doChain
#!/bin/csh
axtChain $1 \
  /iscratch/i/borEut1/nib \
  /iscratch/i/canFam1/nib $2 > $3
'_EOF_'
    # << this line makes emacs coloring happy
    chmod a+x doChain
    gensub2 input.lst single gsub jobList
    para create jobList
    para try, check, push, check...
# Completed: 1 of 1 jobs
# CPU time in finished jobs:        197s       3.28m     0.05h    0.00d  0.000 y
# IO & Wait Time:                    88s       1.47m     0.02h    0.00d  0.000 y
# Average job time:                 285s       4.75m     0.08h    0.00d
# Longest job:                      285s       4.75m     0.08h    0.00d
# Submission to last job:           285s       4.75m     0.08h    0.00d

    # now on the cluster server, sort chains
    ssh kksilo
    cd /cluster/data/borEut1/bed/blastz.canFam1/axtChain
    chainMergeSort run1/chain/*.chain > all.chain
    chainSplit chain all.chain
    rm run1/chain/*.chain

    # take a look at score distr's
    foreach f (chain/*.chain)
      grep chain $f | awk '{print $2;}' | sort -nr > /tmp/score.$f:t:r
      echo $f:t:r
      textHistogram -binSize=4000 /tmp/score.$f:t:r
      echo ""
    end

    mv all.chain all.chain.unfiltered
    chainFilter -minScore=50000 all.chain.unfiltered > all.chain
    rm chain/*
    chainSplit chain all.chain
    gzip all.chain.unfiltered &

    # Load chains into database
    ssh hgwdev
    cd /cluster/data/borEut1/bed/blastz.canFam1/axtChain/chain
    foreach i (*.chain)
        set c = $i:r
        hgLoadChain borEut1 ${c}_chainCanFam1 $i
    end
    featureBits borEut1 chainHg17Link
    # 54236215 bases of 70435997 (77.001%) in intersection

# GENBANK/REFSEQ alignments:
   - added borEut to:
        /cluster/data/genbank/etc/genbank.conf
        src/hg/makeDb/genbank/src/lib/gbGenome.c
        src/hg/makeDb/genbank/src/align/gbBlat
     cvs commit the changes

     cd src/hg/makeDb/genbank
     jkmake install-server
     ssh kksilo
     cd /cluster/data/genbank
     ./bin/gbAlignStep -initial borEut1 &

     # load into database
     ssh hgwdev
     cd /cluster/data/genbank/                
     ./bin/gbDbLoadStep  -initialLoad borEut1 &

# BLASTZ EutGli1
    ssh kk
    mkdir /cluster/data/borEut1/bed/blastz.eutGli1
    cd /cluster/data/borEut1/bed/blastz.eutGli1
    cat << '_EOF_' > DEF
export PATH=/usr/bin:/bin:/usr/local/bin:/cluster/bin/penn:/cluster/bin/i386:/cluster/home/angie/schwartzbin

ALIGN=blastz-run
BLASTZ=blastz

# Default
BLASTZ_H=2000
BLASTZ_ABRIDGE_REPEATS=1

SEQ1_DIR=/iscratch/i/borEut1/nib
SEQ1_RMSK=
SEQ1_FLAG=
# SEQ1_SMSK=/scratch/hg/gs.18/build35/linSpecRep.notInDog
SEQ1_SMSK=
SEQ1_IN_CONTIGS=0
SEQ1_CHUNK=1000000
SEQ1_LAP=10000

SEQ2_DIR=/iscratch/i/eutGli1/nib
SEQ2_RMSK=
SEQ2_FLAG=
#SEQ2_SMSK=/scratch/hg/borEut1/linSpecRep.notInHuman
SEQ2_SMSK=
SEQ2_IN_CONTIGS=0
SEQ2_CHUNK=1000000
SEQ2_LAP=0

BASE=/cluster/data/borEut1/bed/blastz.eutGli1

DEF=$BASE/DEF
RAW=$BASE/raw
CDBDIR=$BASE
SEQ1_LEN=$BASE/S1.len
SEQ2_LEN=$BASE/S2.len
'_EOF_'
    # << this line keeps emacs coloring happy

    /cluster/data/hg17/jkStuff/BlastZ_run0.sh
    cd run.0
    para push
# Completed: 4899 of 4899 jobs
# CPU time in finished jobs:     918787s   15313.12m   255.22h   10.63d  0.029 y
# IO & Wait Time:                 21355s     355.91m     5.93h    0.25d  0.001 y
# Average job time:                 192s       3.20m     0.05h    0.00d
# Longest job:                     2206s      36.77m     0.61h    0.03d
# Submission to last job:          9206s     153.43m     2.56h    0.11d

    ssh kki
    cd /cluster/data/borEut1/bed/blastz.eutGli1
    /cluster/data/hg17/jkStuff/BlastZ_run1.sh

    cd run.1
    para push
# Completed: 71 of 71 jobs
# CPU time in finished jobs:       1139s      18.99m     0.32h    0.01d  0.000 y
# IO & Wait Time:                   797s      13.28m     0.22h    0.01d  0.000 y
# Average job time:                  27s       0.45m     0.01h    0.00d
# Longest job:                       75s       1.25m     0.02h    0.00d
# Submission to last job:           282s       4.70m     0.08h    0.00d

    ssh kk
    cd /cluster/data/borEut1/bed/blastz.eutGli1
    /cluster/data/hg17/jkStuff/BlastZ_run2.sh
    cd run.2
    para push

# Completed: 1 of 1 jobs
# CPU time in finished jobs:        362s       6.04m     0.10h    0.00d  0.000 y
# IO & Wait Time:                  1464s      24.39m     0.41h    0.02d  0.000 y
# Average job time:                1826s      30.43m     0.51h    0.02d
# Longest job:                     1826s      30.43m     0.51h    0.02d
# Submission to last job:          1826s      30.43m     0.51h    0.02d


# END BLASTZ eutGli1


# CHAIN EutGli1 BLASTZ 
    # Run axtChain on little cluster
    ssh kki
    cd /cluster/data/borEut1/bed/blastz.eutGli1
    mkdir -p axtChain/run1
    cd axtChain/run1
    mkdir out chain
    ls -1S /cluster/data/borEut1/bed/blastz.eutGli1/axtChrom/*.axt  > input.lst
    cat << '_EOF_' > gsub
#LOOP
doChain {check in line+ $(path1)} {check out line+ chain/$(root1).chain} {check out exists out/$(root1).out}
#ENDLOOP
'_EOF_'
    # << this line makes emacs coloring happy

    cat << '_EOF_' > doChain
#!/bin/csh
/cluster/bin/x86_64/axtChain $1 \
  /iscratch/i/borEut1/nib \
  /iscratch/i/eutGli1/nib $2 > $3
'_EOF_'
    # << this line makes emacs coloring happy
    chmod a+x doChain
    gensub2 input.lst single gsub jobList
    para create jobList
    para try, check, push, check...
# Completed: 1 of 1 jobs
# CPU time in finished jobs:        197s       3.28m     0.05h    0.00d  0.000 y
# IO & Wait Time:                    88s       1.47m     0.02h    0.00d  0.000 y
# Average job time:                 285s       4.75m     0.08h    0.00d
# Longest job:                      285s       4.75m     0.08h    0.00d
# Submission to last job:           285s       4.75m     0.08h    0.00d

    # now on the cluster server, sort chains
    ssh kksilo
    cd /cluster/data/borEut1/bed/blastz.eutGli1/axtChain
    chainMergeSort run1/chain/*.chain > all.chain
    chainSplit chain all.chain
    rm run1/chain/*.chain

    # take a look at score distr's
    foreach f (chain/*.chain)
      grep chain $f | awk '{print $2;}' | sort -nr > /tmp/score.$f:t:r
      echo $f:t:r
      textHistogram -binSize=4000 /tmp/score.$f:t:r
      echo ""
    end

    mv all.chain all.chain.unfiltered
    chainFilter -minScore=50000 all.chain.unfiltered > all.chain
    rm chain/*
    chainSplit chain all.chain
    gzip all.chain.unfiltered &

    # Load chains into database
    ssh hgwdev
    cd /cluster/data/borEut1/bed/blastz.eutGli1/axtChain/chain
    foreach i (*.chain)
        set c = $i:r
        hgLoadChain borEut1 ${c}_chainEutGli1 $i
    end
    featureBits borEut1 chainEutGli1Link
    # 66936604 bases of 70435997 (95.032%) in intersection

# NET eutGli1 BLASTZ 
    ssh kksilo
    cd /cluster/data/borEut1/bed/blastz.eutGli1/axtChain
    chainPreNet all.chain ../S1.len ../S2.len stdout \
    | chainNet stdin -minSpace=1 ../S1.len ../S2.len stdout /dev/null \
    | netSyntenic stdin noClass.net

    # Add classification info using db tables:
    ssh hgwdev
    cd /cluster/data/borEut1/bed/blastz.eutGli1/axtChain
    netClass -noAr noClass.net borEut1 eutGli1 eutGli1.net

    # Make a 'syntenic' subset:
    ssh kksilo
    cd /cluster/data/borEut1/bed/blastz.eutGli1/axtChain
    rm noClass.net
    # Make a 'syntenic' subset of these with
    netFilter -syn eutGli1.net > eutGli1Syn.net

    # Load the nets into database 
    ssh hgwdev
    cd /cluster/data/borEut1/bed/blastz.eutGli1/axtChain
    netFilter -minGap=10 eutGli1.net |  hgLoadNet borEut1 netEutGli1 stdin
    netFilter -minGap=10 eutGli1Syn.net | hgLoadNet borEut1 netSyntenyEutGli1 stdin
    # Add entries for chainHg17, netHg17, syntenyHg17 to dog/borEut1 trackDb


# GENERATE EutGli1 MAF FOR MULTIZ FROM NET 
    ssh kksilo
    cd /cluster/data/borEut1/bed/blastz.eutGli1/axtChain
    netSplit eutGli1.net net
    cd /cluster/data/borEut1/bed/blastz.eutGli1
    mkdir axtNet
    foreach f (axtChain/net/*)
      set chr = $f:t:r
      netToAxt $f axtChain/chain/$chr.chain /cluster/data/borEut1/nib \
        /cluster/data/eutGli1/nib stdout | axtSort stdin axtNet/$chr.axt
    end
    mkdir mafNet
    foreach f (axtNet/chr*.axt)
    set maf = mafNet/$f:t:r.maf
    axtToMaf $f /cluster/data/borEut1/chrom.sizes /cluster/data/eutGli1/chrom.sizes $maf -tPrefix=borEut1. -qPrefix=eutGli1.
    end
# BLASTZ EutPri1
    ssh kk
    mkdir /cluster/data/borEut1/bed/blastz.eutPri1
    cd /cluster/data/borEut1/bed/blastz.eutPri1
    cat << '_EOF_' > DEF
export PATH=/usr/bin:/bin:/usr/local/bin:/cluster/bin/penn:/cluster/bin/i386:/cluster/home/angie/schwartzbin

ALIGN=blastz-run
BLASTZ=blastz

# Default
BLASTZ_H=2000
BLASTZ_ABRIDGE_REPEATS=1

SEQ1_DIR=/iscratch/i/borEut1/nib
SEQ1_RMSK=
SEQ1_FLAG=
# SEQ1_SMSK=/scratch/hg/gs.18/build35/linSpecRep.notInDog
SEQ1_SMSK=
SEQ1_IN_CONTIGS=0
SEQ1_CHUNK=1000000
SEQ1_LAP=10000

SEQ2_DIR=/iscratch/i/eutPri1/nib
SEQ2_RMSK=
SEQ2_FLAG=
#SEQ2_SMSK=/scratch/hg/borEut1/linSpecRep.notInHuman
SEQ2_SMSK=
SEQ2_IN_CONTIGS=0
SEQ2_CHUNK=1000000
SEQ2_LAP=0

BASE=/cluster/data/borEut1/bed/blastz.eutPri1

DEF=$BASE/DEF
RAW=$BASE/raw
CDBDIR=$BASE
SEQ1_LEN=$BASE/S1.len
SEQ2_LEN=$BASE/S2.len
'_EOF_'
    # << this line keeps emacs coloring happy

    /cluster/data/hg17/jkStuff/BlastZ_run0.sh
    cd run.0
    para push
# Completed: 6319 of 6319 jobs
# CPU time in finished jobs:     144839s    2413.98m    40.23h    1.68d  0.005 y
# IO & Wait Time:                 21882s     364.71m     6.08h    0.25d  0.001 y
# Average job time:                  26s       0.44m     0.01h    0.00d
# Longest job:                     2517s      41.95m     0.70h    0.03d
# Submission to last job:          3900s      65.00m     1.08h    0.05d

    ssh kki
    cd /cluster/data/borEut1/bed/blastz.eutPri1
    /cluster/data/hg17/jkStuff/BlastZ_run1.sh

    cd run.1
    para push
# Completed: 71 of 71 jobs
# CPU time in finished jobs:         72s       1.21m     0.02h    0.00d  0.000 y
# IO & Wait Time:                   211s       3.51m     0.06h    0.00d  0.000 y
# Average job time:                   4s       0.07m     0.00h    0.00d
# Longest job:                       13s       0.22m     0.00h    0.00d
# Submission to last job:            52s       0.87m     0.01h    0.00d

    ssh kk
    cd /cluster/data/borEut1/bed/blastz.eutPri1
    /cluster/data/hg17/jkStuff/BlastZ_run2.sh
    cd run.2
    para push

# Completed: 1 of 1 jobs
# CPU time in finished jobs:         52s       0.86m     0.01h    0.00d  0.000 y
# IO & Wait Time:                    26s       0.44m     0.01h    0.00d  0.000 y
# Average job time:                  78s       1.30m     0.02h    0.00d
# Longest job:                       78s       1.30m     0.02h    0.00d
# Submission to last job:            80s       1.33m     0.02h    0.00d

# END BLASTZ eutPri1

# CHAIN EutPri1 BLASTZ 
    # Run axtChain on little cluster
    ssh kki
    cd /cluster/data/borEut1/bed/blastz.eutPri1
    mkdir -p axtChain/run1
    cd axtChain/run1
    mkdir out chain
    ls -1S /cluster/data/borEut1/bed/blastz.eutPri1/axtChrom/*.axt  > input.lst
    cat << '_EOF_' > gsub
#LOOP
doChain {check in line+ $(path1)} {check out line+ chain/$(root1).chain} {check out exists out/$(root1).out}
#ENDLOOP
'_EOF_'
    # << this line makes emacs coloring happy

    cat << '_EOF_' > doChain
#!/bin/csh
/cluster/bin/x86_64/axtChain $1 \
  /iscratch/i/borEut1/nib \
  /iscratch/i/eutPri1/nib $2 > $3
'_EOF_'
    # << this line makes emacs coloring happy
    chmod a+x doChain
    gensub2 input.lst single gsub jobList
    para create jobList
    para try, check, push, check...
# Completed: 1 of 1 jobs
# CPU time in finished jobs:         72s       1.20m     0.02h    0.00d  0.000 y
# IO & Wait Time:                     7s       0.12m     0.00h    0.00d  0.000 y
# Average job time:                  79s       1.32m     0.02h    0.00d
# Longest job:                       79s       1.32m     0.02h    0.00d
# Submission to last job:            79s       1.32m     0.02h    0.00d

    # now on the cluster server, sort chains
    ssh kksilo
    cd /cluster/data/borEut1/bed/blastz.eutPri1/axtChain
    chainMergeSort run1/chain/*.chain > all.chain
    chainSplit chain all.chain
    rm run1/chain/*.chain

    # take a look at score distr's
    foreach f (chain/*.chain)
      grep chain $f | awk '{print $2;}' | sort -nr > /tmp/score.$f:t:r
      echo $f:t:r
      textHistogram -binSize=4000 /tmp/score.$f:t:r
      echo ""
    end

    mv all.chain all.chain.unfiltered
    chainFilter -minScore=50000 all.chain.unfiltered > all.chain
    rm chain/*
    chainSplit chain all.chain
    gzip all.chain.unfiltered &

    # Load chains into database
    ssh hgwdev
    cd /cluster/data/borEut1/bed/blastz.eutPri1/axtChain/chain
    foreach i (*.chain)
        set c = $i:r
        hgLoadChain borEut1 ${c}_chainEutPri1 $i
    end
    featureBits borEut1 chainEutPri1Link
    # 65181722 bases of 70435997 (92.540%) in intersection

# NET eutPri1 BLASTZ 
    ssh kksilo
    cd /cluster/data/borEut1/bed/blastz.eutPri1/axtChain
    chainPreNet all.chain ../S1.len ../S2.len stdout \
    | chainNet stdin -minSpace=1 ../S1.len ../S2.len stdout /dev/null \
    | netSyntenic stdin noClass.net

    # Add classification info using db tables:
    ssh hgwdev
    cd /cluster/data/borEut1/bed/blastz.eutPri1/axtChain
    netClass -noAr noClass.net borEut1 eutPri1 eutPri1.net

    # Make a 'syntenic' subset:
    ssh kksilo
    cd /cluster/data/borEut1/bed/blastz.eutPri1/axtChain
    rm noClass.net
    # Make a 'syntenic' subset of these with
    netFilter -syn eutPri1.net > eutPri1Syn.net

    # Load the nets into database 
    ssh hgwdev
    cd /cluster/data/borEut1/bed/blastz.eutPri1/axtChain
    netFilter -minGap=10 eutPri1.net |  hgLoadNet borEut1 netEutPri1 stdin
    netFilter -minGap=10 eutPri1Syn.net | hgLoadNet borEut1 netSyntenyEutPri1 stdin
    # Add entries for chainHg17, netHg17, syntenyHg17 to dog/borEut1 trackDb


# GENERATE EutPri1 MAF FOR MULTIZ FROM NET 
    ssh kksilo
    cd /cluster/data/borEut1/bed/blastz.eutPri1/axtChain
    netSplit eutPri1.net net
    cd /cluster/data/borEut1/bed/blastz.eutPri1
    mkdir axtNet
    foreach f (axtChain/net/*)
      set chr = $f:t:r
      netToAxt $f axtChain/chain/$chr.chain /cluster/data/borEut1/nib \
        /cluster/data/eutPri1/nib stdout | axtSort stdin axtNet/$chr.axt
    end
    mkdir mafNet
    foreach f (axtNet/chr*.axt)
    set maf = mafNet/$f:t:r.maf
    axtToMaf $f /cluster/data/borEut1/chrom.sizes /cluster/data/eutPri1/chrom.sizes $maf -tPrefix=borEut1. -qPrefix=eutPri1.
    end

# Load into database
  ssh hgwdev
  cd /cluster/data/borEut1/bed/multizDescend
  /cluster/bin/pen
  mkdir -p /gbdb/borEut1/multiz4way
  ln -s /cluster/data/borEut1/bed/multizDescend/multiz4way.maf /gbdb/borEut1/multiz4way
  hgLoadMaf borEut1 multiz4way

    /cluster/bin/penn/maf_project global4way.maf  borEut1.chr15 > multiz4way.maf

      for i in eutGli1 eutPri1 hg17
      do
	  f="$i"_netBlastz
	  mkdir -p /gbdb/borEut1/multiz4way/$f
	  ln -s /cluster/data/borEut1/bed/blastz.$i/chr15.maf /gbdb/borEut1/multiz4way/$f/$i.maf
	  hgLoadMaf borEut1 $f -pathPrefix=/gbdb/borEut1/multiz4way/$f
      done
